<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pillar Layout Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 20px;
            height: calc(100vh - 40px);
        }
        
        .panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 20px;
        }
        
        .controls {
            overflow-y: auto;
        }
        
        .canvas-panel {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .canvas-container {
            flex: 1;
            min-height: 0;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #sideView {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            font-size: 11px;
            font-family: 'Monaco', 'Courier New', monospace;
        }
        
        h2 {
            font-size: 18px;
            margin-bottom: 16px;
            color: #333;
        }
        
        .control-group {
            margin-bottom: 16px;
        }
        
        label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            color: #555;
            margin-bottom: 4px;
        }
        
        select, input[type="number"] {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .dual-input {
            display: grid;
            grid-template-columns: 1fr 80px;
            gap: 8px;
            align-items: center;
        }
        
        .dual-input input[type="number"] {
            padding: 4px 6px;
            font-size: 12px;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        .range-value {
            font-size: 12px;
            color: #666;
            float: right;
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            margin-top: 4px;
            cursor: pointer;
        }
        
        .checkbox-label input[type="checkbox"] {
            cursor: pointer;
        }
        
        .dimension-lock {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 8px;
            margin-top: 8px;
        }
        
        .dimension-lock input[type="number"] {
            font-size: 12px;
            padding: 4px 6px;
        }
        
        .dimension-lock button {
            padding: 4px 12px;
            margin: 0;
            font-size: 12px;
            white-space: nowrap;
        }
        
        canvas {
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #fafafa;
            display: block;
        }
        
        .stats {
            margin-bottom: 12px;
            padding: 12px;
            background: #f9f9f9;
            border-radius: 4px;
            font-size: 12px;
            font-family: 'Monaco', 'Courier New', monospace;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .stats div {
            margin: 4px 0;
            color: #555;
        }
        
        button {
            width: 100%;
            padding: 12px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            margin-top: 16px;
            transition: background 0.2s;
        }
        
        button:hover:not(:disabled) {
            background: #357abd;
        }
        
        button:disabled {
            background: #999;
            cursor: not-allowed;
        }
        
        .generation-status {
            text-align: center;
            margin-top: 8px;
            font-size: 12px;
            color: #666;
            min-height: 18px;
        }
        
        .zoom-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .zoom-control label {
            margin: 0;
            font-size: 12px;
        }
        
        .zoom-control input[type="range"] {
            flex: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel controls">
            <h2>Parameters</h2>
            
            <div class="control-group">
                <label>Layout Type</label>
                <select id="layoutType">
                    <option value="square-checkerboard">Square Checkerboard</option>
                    <option value="hex-checkerboard" selected>Hex Checkerboard</option>
                    <option value="hex-honeycomb">Hex Honeycomb</option>
                    <option value="organic">Organic</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Rows <span class="range-value" id="rowsValue">10</span></label>
                <div class="dual-input">
                    <input type="range" id="rows" min="1" max="100" value="10" step="1">
                    <input type="number" id="rowsNum" min="1" max="100" value="10" step="1">
                </div>
            </div>
            
            <div class="control-group">
                <label>Columns <span class="range-value" id="colsValue">10</span></label>
                <div class="dual-input">
                    <input type="range" id="cols" min="1" max="100" value="10" step="1">
                    <input type="number" id="colsNum" min="1" max="100" value="10" step="1">
                </div>
            </div>
            
            <div class="control-group">
                <label>Spacing (mm) <span class="range-value" id="spacingValue">0.35</span></label>
                <div class="dual-input">
                    <input type="range" id="spacing" min="0.001" max="1.0" value="0.35" step="0.001">
                    <input type="number" id="spacingNum" min="0.001" max="1.0" value="0.35" step="0.001">
                </div>
            </div>
            
            <div class="control-group">
                <label>Pillar Radius (mm) <span class="range-value" id="pillarRadiusValue">0.125</span></label>
                <div class="dual-input">
                    <input type="range" id="pillarRadius" min="0.001" max="1.0" value="0.125" step="0.001">
                    <input type="number" id="pillarRadiusNum" min="0.001" max="1.0" value="0.125" step="0.001">
                </div>
            </div>
            
            <div class="control-group">
                <label>Pillar Height (mm) <span class="range-value" id="pillarHeightValue">10.0</span></label>
                <div class="dual-input">
                    <input type="range" id="pillarHeight" min="0.1" max="20.0" value="10.0" step="0.1">
                    <input type="number" id="pillarHeightNum" min="0.1" max="20.0" value="10.0" step="0.1">
                </div>
            </div>
            
            <div class="control-group">
                <label>Hole Radius (mm) <span class="range-value" id="holeRadiusValue">0.10</span></label>
                <div class="dual-input">
                    <input type="range" id="holeRadius" min="0.001" max="1.0" value="0.10" step="0.001">
                    <input type="number" id="holeRadiusNum" min="0.001" max="1.0" value="0.10" step="0.001">
                </div>
            </div>
            
            <div class="control-group">
                <label>Floor Thickness (mm) <span class="range-value" id="floorThicknessValue">2.0</span></label>
                <div class="dual-input">
                    <input type="range" id="floorThickness" min="0.1" max="5.0" value="2.0" step="0.1">
                    <input type="number" id="floorThicknessNum" min="0.1" max="5.0" value="2.0" step="0.1">
                </div>
            </div>
            
            <div class="control-group">
                <label>Floor Padding X (mm) <span class="range-value" id="floorPaddingXValue">0.25</span></label>
                <div class="dual-input">
                    <input type="range" id="floorPaddingX" min="-5.0" max="5.0" value="0.25" step="0.00001">
                    <input type="number" id="floorPaddingXNum" value="0.25" step="0.00001">
                </div>
                <div class="dimension-lock">
                    <input type="number" id="targetWidth" placeholder="Target inner width (mm)" step="0.00001">
                    <button type="button" id="lockWidth">Lock Width</button>
                </div>
            </div>
            
            <div class="control-group">
                <label>Floor Padding Y (mm) <span class="range-value" id="floorPaddingYValue">0.25</span></label>
                <div class="dual-input">
                    <input type="range" id="floorPaddingY" min="-5.0" max="5.0" value="0.25" step="0.00001">
                    <input type="number" id="floorPaddingYNum" value="0.25" step="0.00001">
                </div>
                <div class="dimension-lock">
                    <input type="number" id="targetHeight" placeholder="Target inner height (mm)" step="0.00001">
                    <button type="button" id="lockHeight">Lock Height</button>
                </div>
                <label class="checkbox-label">
                    <input type="checkbox" id="linkPadding" checked>
                    Link X and Y padding
                </label>
            </div>
            
            <div class="control-group">
                <label>Wall Thickness (mm) <span class="range-value" id="wallThicknessValue">2.0</span></label>
                <div class="dual-input">
                    <input type="range" id="wallThickness" min="0.0" max="10.0" value="2.0" step="0.1">
                    <input type="number" id="wallThicknessNum" min="0.0" max="10.0" value="2.0" step="0.1">
                </div>
            </div>
            
            <div id="organicControls" style="display: none;">
                <div class="control-group">
                    <label>Jitter (mm) <span class="range-value" id="jitterValue">0.05</span></label>
                    <div class="dual-input">
                        <input type="range" id="jitter" min="0.0" max="1.0" value="0.05" step="0.001">
                        <input type="number" id="jitterNum" min="0.0" max="1.0" value="0.05" step="0.001">
                    </div>
                </div>
                
                <div class="control-group">
                    <label>Hole Probability <span class="range-value" id="holeProbValue">0.20</span></label>
                    <div class="dual-input">
                        <input type="range" id="holeProb" min="0.0" max="1.0" value="0.20" step="0.001">
                        <input type="number" id="holeProbNum" min="0.0" max="1.0" value="0.20" step="0.001">
                    </div>
                </div>
                
                <div class="control-group">
                    <label>Random Seed</label>
                    <input type="number" id="seed" value="42">
                </div>
            </div>
            
            <button id="generateBtn">Generate STL</button>
            <div class="generation-status" id="status"></div>
        </div>
        
        <div class="panel canvas-panel">
            <h2>Top-Down Preview</h2>
            <div class="stats" id="stats">
                <div>Pillars: <span id="statPillars">-</span></div>
                <div>Holes: <span id="statHoles">-</span></div>
                <div>Inner: <span id="statDims">-</span></div>
                <div>Total: <span id="statTotal">-</span></div>
                <div>Density: <span id="statDensity">-</span></div>
                <div>Height: <span id="statHeight">-</span></div>
            </div>
            <div class="zoom-control">
                <label>Zoom:</label>
                <input type="range" id="zoomSlider" min="0.3" max="2.0" value="0.85" step="0.05">
                <span id="zoomValue">85%</span>
            </div>
            <div class="zoom-control">
                <label class="checkbox-label">
                    <input type="checkbox" id="showMeasurements">
                    Show Measurements
                </label>
            </div>
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
                <div id="sideView" style="display: none;"></div>
            </div>
        </div>
    </div>

    <script>
        const API_URL = window.location.hostname === 'localhost' 
            ? 'http://localhost:5000' 
            : window.location.origin;
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let debounceTimer = null;
        let isUpdating = false;
        let pendingUpdate = false;
        let previewZoom = 0.85;
        let widthLocked = false;
        let heightLocked = false;
        let showMeasurements = false;
        
        // Resize canvas to match container while maintaining aspect ratio
        function resizeCanvas() {
            const container = canvas.parentElement;
            const dpr = window.devicePixelRatio || 1;
            
            canvas.width = container.clientWidth * dpr;
            canvas.height = container.clientHeight * dpr;
            
            canvas.style.width = container.clientWidth + 'px';
            canvas.style.height = container.clientHeight + 'px';
            
            ctx.scale(dpr, dpr);
            
            if (window.lastPreviewData) {
                drawPreview(window.lastPreviewData);
            }
        }
        
        // Initial resize and setup resize observer
        resizeCanvas();
        new ResizeObserver(resizeCanvas).observe(canvas.parentElement);
        
        // Parameters
        const params = {
            layoutType: document.getElementById('layoutType'),
            rows: document.getElementById('rows'),
            rowsNum: document.getElementById('rowsNum'),
            cols: document.getElementById('cols'),
            colsNum: document.getElementById('colsNum'),
            spacing: document.getElementById('spacing'),
            spacingNum: document.getElementById('spacingNum'),
            pillarRadius: document.getElementById('pillarRadius'),
            pillarRadiusNum: document.getElementById('pillarRadiusNum'),
            pillarHeight: document.getElementById('pillarHeight'),
            pillarHeightNum: document.getElementById('pillarHeightNum'),
            holeRadius: document.getElementById('holeRadius'),
            holeRadiusNum: document.getElementById('holeRadiusNum'),
            floorThickness: document.getElementById('floorThickness'),
            floorThicknessNum: document.getElementById('floorThicknessNum'),
            floorPaddingX: document.getElementById('floorPaddingX'),
            floorPaddingXNum: document.getElementById('floorPaddingXNum'),
            floorPaddingY: document.getElementById('floorPaddingY'),
            floorPaddingYNum: document.getElementById('floorPaddingYNum'),
            linkPadding: document.getElementById('linkPadding'),
            wallThickness: document.getElementById('wallThickness'),
            wallThicknessNum: document.getElementById('wallThicknessNum'),
            jitter: document.getElementById('jitter'),
            jitterNum: document.getElementById('jitterNum'),
            holeProb: document.getElementById('holeProb'),
            holeProbNum: document.getElementById('holeProbNum'),
            seed: document.getElementById('seed')
        };
        
        // Sync dual inputs
        const dualPairs = [
            ['rows', 'rowsNum'],
            ['cols', 'colsNum'],
            ['spacing', 'spacingNum'],
            ['pillarRadius', 'pillarRadiusNum'],
            ['pillarHeight', 'pillarHeightNum'],
            ['holeRadius', 'holeRadiusNum'],
            ['floorThickness', 'floorThicknessNum'],
            ['floorPaddingX', 'floorPaddingXNum'],
            ['floorPaddingY', 'floorPaddingYNum'],
            ['wallThickness', 'wallThicknessNum'],
            ['jitter', 'jitterNum'],
            ['holeProb', 'holeProbNum']
        ];
        
        dualPairs.forEach(([slider, number]) => {
            const sliderEl = params[slider];
            const numberEl = params[number];
            
            sliderEl.addEventListener('input', () => {
                const val = sliderEl.value;
                numberEl.value = val;
                const valueSpan = document.getElementById(slider + 'Value');
                if (valueSpan) valueSpan.textContent = val;
                
                // Handle linked padding
                if ((slider === 'floorPaddingX' || slider === 'floorPaddingY') && params.linkPadding.checked) {
                    const otherSlider = slider === 'floorPaddingX' ? 'floorPaddingY' : 'floorPaddingX';
                    const otherNumber = number.replace('X', 'Y').replace('Y', slider === 'floorPaddingX' ? 'Y' : 'X');
                    params[otherSlider].value = val;
                    params[otherNumber].value = val;
                    const otherSpan = document.getElementById(otherSlider + 'Value');
                    if (otherSpan) otherSpan.textContent = val;
                }
                
                debouncedUpdate();
            });
            
            numberEl.addEventListener('input', () => {
                const val = numberEl.value;
                sliderEl.value = val;
                const valueSpan = document.getElementById(slider + 'Value');
                if (valueSpan) valueSpan.textContent = val;
                
                // Handle linked padding
                if ((number === 'floorPaddingXNum' || number === 'floorPaddingYNum') && params.linkPadding.checked) {
                    const otherSlider = slider === 'floorPaddingX' ? 'floorPaddingY' : 'floorPaddingX';
                    const otherNumber = number.replace('X', 'Y').replace('Y', number === 'floorPaddingXNum' ? 'Y' : 'X');
                    params[otherSlider].value = val;
                    params[otherNumber].value = val;
                    const otherSpan = document.getElementById(otherSlider + 'Value');
                    if (otherSpan) otherSpan.textContent = val;
                }
                
                debouncedUpdate();
            });
        });
        
        // Update range value displays
        Object.entries(params).forEach(([key, input]) => {
            if (input.type === 'range' && !key.endsWith('Num')) {
                const valueSpan = document.getElementById(key + 'Value');
                if (valueSpan) {
                    input.addEventListener('input', () => {
                        valueSpan.textContent = input.value;
                    });
                }
            }
        });
        
        // Layout type change
        params.layoutType.addEventListener('change', () => {
            const isOrganic = params.layoutType.value === 'organic';
            document.getElementById('organicControls').style.display = isOrganic ? 'block' : 'none';
            debouncedUpdate();
        });
        
        // Other inputs
        params.seed.addEventListener('change', debouncedUpdate);
        params.linkPadding.addEventListener('change', debouncedUpdate);
        
        // Dimension lock functionality
        document.getElementById('lockWidth').addEventListener('click', () => {
            const targetWidth = parseFloat(document.getElementById('targetWidth').value);
            if (isNaN(targetWidth) || !window.lastPreviewData) return;
            
            widthLocked = !widthLocked;
            document.getElementById('lockWidth').textContent = widthLocked ? 'Unlock Width' : 'Lock Width';
            document.getElementById('lockWidth').style.background = widthLocked ? '#e74c3c' : '#4a90e2';
            
            if (widthLocked) {
                const { pillars, holes } = window.lastPreviewData;
                const allPositions = [...pillars, ...holes];
                const xValues = allPositions.map(p => p.x);
                const rawWidth = Math.max(...xValues) - Math.min(...xValues);
                const requiredPaddingX = (targetWidth - rawWidth) / 2;
                
                params.floorPaddingX.value = requiredPaddingX.toFixed(5);
                params.floorPaddingXNum.value = requiredPaddingX.toFixed(5);
                document.getElementById('floorPaddingXValue').textContent = requiredPaddingX.toFixed(5);
                debouncedUpdate();
            }
        });
        
        document.getElementById('lockHeight').addEventListener('click', () => {
            const targetHeight = parseFloat(document.getElementById('targetHeight').value);
            if (isNaN(targetHeight) || !window.lastPreviewData) return;
            
            heightLocked = !heightLocked;
            document.getElementById('lockHeight').textContent = heightLocked ? 'Unlock Height' : 'Lock Height';
            document.getElementById('lockHeight').style.background = heightLocked ? '#e74c3c' : '#4a90e2';
            
            if (heightLocked) {
                const { pillars, holes } = window.lastPreviewData;
                const allPositions = [...pillars, ...holes];
                const yValues = allPositions.map(p => p.y);
                const rawHeight = Math.max(...yValues) - Math.min(...yValues);
                const requiredPaddingY = (targetHeight - rawHeight) / 2;
                
                params.floorPaddingY.value = requiredPaddingY.toFixed(5);
                params.floorPaddingYNum.value = requiredPaddingY.toFixed(5);
                document.getElementById('floorPaddingYValue').textContent = requiredPaddingY.toFixed(5);
                debouncedUpdate();
            }
        });
        
        // Zoom control
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomValue = document.getElementById('zoomValue');
        zoomSlider.addEventListener('input', () => {
            previewZoom = parseFloat(zoomSlider.value);
            zoomValue.textContent = Math.round(previewZoom * 100) + '%';
            if (window.lastPreviewData) {
                drawPreview(window.lastPreviewData);
            }
        });
        
        // Measurements toggle
        const measurementsToggle = document.getElementById('showMeasurements');
        measurementsToggle.addEventListener('change', () => {
            showMeasurements = measurementsToggle.checked;
            document.getElementById('sideView').style.display = showMeasurements ? 'block' : 'none';
            if (window.lastPreviewData) {
                drawPreview(window.lastPreviewData);
                if (showMeasurements) {
                    drawSideView();
                }
            }
        });
        
        // Show organic controls if needed
        if (params.layoutType.value === 'organic') {
            document.getElementById('organicControls').style.display = 'block';
        }
        
        function debouncedUpdate() {
            pendingUpdate = true;
            
            if (debounceTimer) {
                clearTimeout(debounceTimer);
            }
            
            debounceTimer = setTimeout(() => {
                if (!isUpdating && pendingUpdate) {
                    updatePreview();
                }
            }, 10);
        }
        
        async function updatePreview() {
            if (isUpdating) {
                pendingUpdate = true;
                return;
            }
            
            isUpdating = true;
            pendingUpdate = false;
            
            const data = {
                layout_type: params.layoutType.value,
                rows: parseInt(params.rows.value),
                cols: parseInt(params.cols.value),
                spacing: parseFloat(params.spacing.value),
                floor_padding_x: parseFloat(params.floorPaddingX.value),
                floor_padding_y: parseFloat(params.floorPaddingY.value),
                hole_probability: parseFloat(params.holeProb.value),
                jitter: parseFloat(params.jitter.value),
                seed: parseInt(params.seed.value)
            };
            
            try {
                const response = await fetch(`${API_URL}/preview`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                
                const result = await response.json();
                window.lastPreviewData = result;
                
                // Recalculate locked dimensions if needed
                let paddingChanged = false;
                
                if (widthLocked) {
                    const targetWidth = parseFloat(document.getElementById('targetWidth').value);
                    if (!isNaN(targetWidth)) {
                        const { pillars, holes } = result;
                        const allPositions = [...pillars, ...holes];
                        const xValues = allPositions.map(p => p.x);
                        const rawWidth = Math.max(...xValues) - Math.min(...xValues);
                        const requiredPaddingX = (targetWidth - rawWidth) / 2;
                        
                        params.floorPaddingX.value = requiredPaddingX.toFixed(5);
                        params.floorPaddingXNum.value = requiredPaddingX.toFixed(5);
                        document.getElementById('floorPaddingXValue').textContent = requiredPaddingX.toFixed(5);
                        paddingChanged = true;
                    }
                }
                
                if (heightLocked) {
                    const targetHeight = parseFloat(document.getElementById('targetHeight').value);
                    if (!isNaN(targetHeight)) {
                        const { pillars, holes } = result;
                        const allPositions = [...pillars, ...holes];
                        const yValues = allPositions.map(p => p.y);
                        const rawHeight = Math.max(...yValues) - Math.min(...yValues);
                        const requiredPaddingY = (targetHeight - rawHeight) / 2;
                        
                        params.floorPaddingY.value = requiredPaddingY.toFixed(5);
                        params.floorPaddingYNum.value = requiredPaddingY.toFixed(5);
                        document.getElementById('floorPaddingYValue').textContent = requiredPaddingY.toFixed(5);
                        paddingChanged = true;
                    }
                }
                
                // If padding was recalculated, fetch new preview with updated padding
                if (paddingChanged) {
                    const newData = {
                        layout_type: params.layoutType.value,
                        rows: parseInt(params.rows.value),
                        cols: parseInt(params.cols.value),
                        spacing: parseFloat(params.spacing.value),
                        floor_padding_x: parseFloat(params.floorPaddingX.value),
                        floor_padding_y: parseFloat(params.floorPaddingY.value),
                        hole_probability: parseFloat(params.holeProb.value),
                        jitter: parseFloat(params.jitter.value),
                        seed: parseInt(params.seed.value)
                    };
                    
                    const newResponse = await fetch(`${API_URL}/preview`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(newData)
                    });
                    
                    const updatedResult = await newResponse.json();
                    window.lastPreviewData = updatedResult;
                    drawPreview(updatedResult);
                    updateStats(updatedResult);
                } else {
                    drawPreview(result);
                    updateStats(result);
                }
                
                if (showMeasurements) {
                    drawSideView();
                }
            } catch (error) {
                console.error('Preview error:', error);
            } finally {
                isUpdating = false;
                
                if (pendingUpdate) {
                    setTimeout(() => updatePreview(), 10);
                }
            }
        }
        
        function drawPreview(data) {
            const { pillars, holes, bounds } = data;
            
            const container = canvas.parentElement;
            const canvasWidth = container.clientWidth;
            const canvasHeight = container.clientHeight;
            
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            const innerWidth = bounds.maxX - bounds.minX;
            const innerHeight = bounds.maxY - bounds.minY;
            const wt = parseFloat(params.wallThickness.value);
            const totalWidth = innerWidth + 2 * wt;
            const totalHeight = innerHeight + 2 * wt;
            
            const scale = Math.min(canvasWidth, canvasHeight) * previewZoom / Math.max(totalWidth, totalHeight);
            
            const offsetX = canvasWidth / 2 - (bounds.minX + bounds.maxX) / 2 * scale;
            const offsetY = canvasHeight / 2 - (bounds.minY + bounds.maxY) / 2 * scale;
            
            const toScreen = (x, y) => ({
                x: x * scale + offsetX,
                y: y * scale + offsetY
            });
            
            // Draw walls
            ctx.fillStyle = 'rgba(100, 100, 100, 0.2)';
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            const wtScaled = wt * scale;
            ctx.fillRect(bounds.minX * scale + offsetX - wtScaled, bounds.minY * scale + offsetY - wtScaled, innerWidth * scale + 2*wtScaled, wtScaled);
            ctx.strokeRect(bounds.minX * scale + offsetX - wtScaled, bounds.minY * scale + offsetY - wtScaled, innerWidth * scale + 2*wtScaled, wtScaled);
            ctx.fillRect(bounds.minX * scale + offsetX - wtScaled, bounds.maxY * scale + offsetY, innerWidth * scale + 2*wtScaled, wtScaled);
            ctx.strokeRect(bounds.minX * scale + offsetX - wtScaled, bounds.maxY * scale + offsetY, innerWidth * scale + 2*wtScaled, wtScaled);
            ctx.fillRect(bounds.minX * scale + offsetX - wtScaled, bounds.minY * scale + offsetY, wtScaled, innerHeight * scale);
            ctx.strokeRect(bounds.minX * scale + offsetX - wtScaled, bounds.minY * scale + offsetY, wtScaled, innerHeight * scale);
            ctx.fillRect(bounds.maxX * scale + offsetX, bounds.minY * scale + offsetY, wtScaled, innerHeight * scale);
            ctx.strokeRect(bounds.maxX * scale + offsetX, bounds.minY * scale + offsetY, wtScaled, innerHeight * scale);
            
            // Draw floor outline
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 2;
            ctx.strokeRect(
                bounds.minX * scale + offsetX,
                bounds.minY * scale + offsetY,
                innerWidth * scale,
                innerHeight * scale
            );
            
            // Draw holes (batched)
            const holeRadius = parseFloat(params.holeRadius.value) * scale;
            ctx.fillStyle = 'rgba(255, 100, 100, 0.5)';
            ctx.beginPath();
            holes.forEach(hole => {
                const pos = toScreen(hole.x, hole.y);
                ctx.moveTo(pos.x + holeRadius, pos.y);
                ctx.arc(pos.x, pos.y, holeRadius, 0, Math.PI * 2);
            });
            ctx.fill();
        }
        
        function drawDimensionLine(ctx, x1, y1, x2, y2, label, offset = 20) {
            ctx.save();
            ctx.strokeStyle = '#e74c3c';
            ctx.fillStyle = '#e74c3c';
            ctx.lineWidth = 1.5;
            
            // Calculate perpendicular offset
            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            const perpX = -dy / length * offset;
            const perpY = dx / length * offset;
            
            const startX = x1 + perpX;
            const startY = y1 + perpY;
            const endX = x2 + perpX;
            const endY = y2 + perpY;
            
            // Draw main line
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            // Draw end caps
            const capSize = 8;
            ctx.beginPath();
            ctx.moveTo(startX - perpY/offset * capSize, startY + perpX/offset * capSize);
            ctx.lineTo(startX + perpY/offset * capSize, startY - perpX/offset * capSize);
            ctx.moveTo(endX - perpY/offset * capSize, endY + perpX/offset * capSize);
            ctx.lineTo(endX + perpY/offset * capSize, endY - perpX/offset * capSize);
            ctx.stroke();
            
            // Draw leader lines
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(startX, startY);
            ctx.moveTo(x2, y2);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw label
            const midX = (startX + endX) / 2;
            const midY = (startY + endY) / 2;
            ctx.font = 'bold 12px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Background for text
            const metrics = ctx.measureText(label);
            const padding = 4;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(midX - metrics.width/2 - padding, midY - 8, metrics.width + padding*2, 16);
            
            ctx.fillStyle = '#e74c3c';
            ctx.fillText(label, midX, midY);
            
            ctx.restore();
        }
        
        function drawRadiusLine(ctx, centerX, centerY, radius, label, angle = 45) {
            ctx.save();
            ctx.strokeStyle = '#e74c3c';
            ctx.fillStyle = '#e74c3c';
            ctx.lineWidth = 1.5;
            
            const rad = angle * Math.PI / 180;
            const endX = centerX + Math.cos(rad) * radius;
            const endY = centerY + Math.sin(rad) * radius;
            
            // Draw radius line
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            // Draw center dot
            ctx.beginPath();
            ctx.arc(centerX, centerY, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw label
            const labelX = centerX + Math.cos(rad) * (radius + 20);
            const labelY = centerY + Math.sin(rad) * (radius + 20);
            
            ctx.font = 'bold 12px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const metrics = ctx.measureText(label);
            const padding = 4;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(labelX - metrics.width/2 - padding, labelY - 8, metrics.width + padding*2, 16);
            
            ctx.fillStyle = '#e74c3c';
            ctx.fillText(label, labelX, labelY);
            
            ctx.restore();
        }
        
        function drawBracket(ctx, x1, y1, x2, y2, label, side = 'outside') {
            ctx.save();
            ctx.strokeStyle = '#9b59b6';
            ctx.fillStyle = '#9b59b6';
            ctx.lineWidth = 1.5;
            
            const isHorizontal = Math.abs(y2 - y1) < Math.abs(x2 - x1);
            const bracketSize = 15;
            
            // Draw main bracket line
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            // Draw end brackets
            if (isHorizontal) {
                ctx.beginPath();
                ctx.moveTo(x1, y1 - bracketSize/2);
                ctx.lineTo(x1, y1 + bracketSize/2);
                ctx.moveTo(x2, y2 - bracketSize/2);
                ctx.lineTo(x2, y2 + bracketSize/2);
                ctx.stroke();
            } else {
                ctx.beginPath();
                ctx.moveTo(x1 - bracketSize/2, y1);
                ctx.lineTo(x1 + bracketSize/2, y1);
                ctx.moveTo(x2 - bracketSize/2, y2);
                ctx.lineTo(x2 + bracketSize/2, y2);
                ctx.stroke();
            }
            
            // Draw label
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            ctx.font = 'bold 12px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const metrics = ctx.measureText(label);
            const padding = 4;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(midX - metrics.width/2 - padding, midY - 8, metrics.width + padding*2, 16);
            
            ctx.fillStyle = '#9b59b6';
            ctx.fillText(label, midX, midY);
            
            ctx.restore();
        }
        
        function drawMeasurements(data, scale, offsetX, offsetY, bounds) {
            const { pillars, holes } = data;
            const spacing = parseFloat(params.spacing.value);
            const pillarRadiusValue = parseFloat(params.pillarRadius.value);
            const holeRadiusValue = parseFloat(params.holeRadius.value);
            const floorPaddingX = parseFloat(params.floorPaddingX.value);
            const floorPaddingY = parseFloat(params.floorPaddingY.value);
            const wt = parseFloat(params.wallThickness.value);
            
            if (pillars.length < 2) return;
            
            // Find two adjacent pillars for spacing annotation
            let pillar1 = null, pillar2 = null;
            const sortedPillars = [...pillars].sort((a, b) => a.y - b.y || a.x - b.x);
            
            for (let i = 0; i < sortedPillars.length - 1; i++) {
                const p1 = sortedPillars[i];
                const p2 = sortedPillars[i + 1];
                const dist = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
                
                // Find pillars at roughly spacing distance
                if (Math.abs(dist - spacing) < 0.01) {
                    pillar1 = p1;
                    pillar2 = p2;
                    break;
                }
            }
            
            // Draw spacing dimension
            if (pillar1 && pillar2) {
                const p1Screen = {
                    x: pillar1.x * scale + offsetX,
                    y: pillar1.y * scale + offsetY
                };
                const p2Screen = {
                    x: pillar2.x * scale + offsetX,
                    y: pillar2.y * scale + offsetY
                };
                
                drawDimensionLine(
                    ctx, 
                    p1Screen.x, p1Screen.y,
                    p2Screen.x, p2Screen.y,
                    `Spacing: ${spacing.toFixed(3)} mm`,
                    -30
                );
            }
            
            // Draw pillar radius on first pillar
            if (pillars.length > 0) {
                const pillar = pillars[0];
                const pillarScreen = {
                    x: pillar.x * scale + offsetX,
                    y: pillar.y * scale + offsetY
                };
                const pillarRadiusScaled = pillarRadiusValue * scale;
                
                drawRadiusLine(
                    ctx,
                    pillarScreen.x,
                    pillarScreen.y,
                    pillarRadiusScaled,
                    `r=${pillarRadiusValue.toFixed(3)}`,
                    -45
                );
            }
            
            // Draw hole radius on first hole
            if (holes.length > 0) {
                const hole = holes[0];
                const holeScreen = {
                    x: hole.x * scale + offsetX,
                    y: hole.y * scale + offsetY
                };
                const holeRadiusScaled = holeRadiusValue * scale;
                
                drawRadiusLine(
                    ctx,
                    holeScreen.x,
                    holeScreen.y,
                    holeRadiusScaled,
                    `r=${holeRadiusValue.toFixed(3)}`,
                    135
                );
            }
            
            // Draw floor padding (left side)
            const innerWidth = bounds.maxX - bounds.minX;
            const innerHeight = bounds.maxY - bounds.minY;
            
            const floorLeftX = bounds.minX * scale + offsetX;
            const floorTopY = bounds.minY * scale + offsetY;
            const wtScaled = wt * scale;
            const paddingXScaled = floorPaddingX * scale;
            const paddingYScaled = floorPaddingY * scale;
            
            // Vertical bracket for padding Y (left side)
            drawBracket(
                ctx,
                floorLeftX - wtScaled - 30,
                floorTopY,
                floorLeftX - wtScaled - 30,
                floorTopY + paddingYScaled,
                `Pad: ${floorPaddingY.toFixed(3)}`
            );
            
            // Horizontal bracket for padding X (top side)
            drawBracket(
                ctx,
                floorLeftX,
                floorTopY - wtScaled - 30,
                floorLeftX + paddingXScaled,
                floorTopY - wtScaled - 30,
                `Pad: ${floorPaddingX.toFixed(3)}`
            );
            
            // Wall thickness annotation (left wall)
            if (wt > 0) {
                drawBracket(
                    ctx,
                    floorLeftX - wtScaled,
                    floorTopY + innerHeight * scale / 2,
                    floorLeftX,
                    floorTopY + innerHeight * scale / 2,
                    `Wall: ${wt.toFixed(2)}`
                );
            }
        }
        
        function drawSideView() {
            const floorThickness = parseFloat(params.floorThickness.value);
            const pillarHeight = parseFloat(params.pillarHeight.value);
            const totalHeight = floorThickness + pillarHeight;
            
            const svg = `
                <svg width="200" height="120" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <pattern id="hatch" patternUnits="userSpaceOnUse" width="4" height="4">
                            <path d="M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2" stroke="#999" stroke-width="0.5"/>
                        </pattern>
                    </defs>
                    
                    <!-- Floor -->
                    <rect x="30" y="${90 - floorThickness * 3}" width="120" height="${floorThickness * 3}" 
                          fill="url(#hatch)" stroke="#666" stroke-width="1"/>
                    
                    <!-- Pillar -->
                    <rect x="70" y="${90 - totalHeight * 3}" width="40" height="${pillarHeight * 3}" 
                          fill="rgba(50, 120, 200, 0.5)" stroke="#357abd" stroke-width="1.5"/>
                    
                    <!-- Dimension lines -->
                    <line x1="160" y1="90" x2="160" y2="${90 - floorThickness * 3}" 
                          stroke="#e74c3c" stroke-width="1.5"/>
                    <line x1="157" y1="90" x2="163" y2="90" stroke="#e74c3c" stroke-width="1.5"/>
                    <line x1="157" y1="${90 - floorThickness * 3}" x2="163" y2="${90 - floorThickness * 3}" 
                          stroke="#e74c3c" stroke-width="1.5"/>
                    <text x="170" y="${90 - floorThickness * 1.5}" fill="#e74c3c" font-size="10" font-weight="bold">
                        ${floorThickness.toFixed(1)}
                    </text>
                    
                    <line x1="170" y1="${90 - floorThickness * 3}" x2="170" y2="${90 - totalHeight * 3}" 
                          stroke="#e74c3c" stroke-width="1.5"/>
                    <line x1="167" y1="${90 - floorThickness * 3}" x2="173" y2="${90 - floorThickness * 3}" 
                          stroke="#e74c3c" stroke-width="1.5"/>
                    <line x1="167" y1="${90 - totalHeight * 3}" x2="173" y2="${90 - totalHeight * 3}" 
                          stroke="#e74c3c" stroke-width="1.5"/>
                    <text x="180" y="${90 - (floorThickness + pillarHeight/2) * 3}" fill="#e74c3c" 
                          font-size="10" font-weight="bold">
                        ${pillarHeight.toFixed(1)}
                    </text>
                    
                    <!-- Total height -->
                    <line x1="20" y1="90" x2="20" y2="${90 - totalHeight * 3}" 
                          stroke="#9b59b6" stroke-width="1.5" stroke-dasharray="3,3"/>
                    <line x1="17" y1="90" x2="23" y2="90" stroke="#9b59b6" stroke-width="1.5"/>
                    <line x1="17" y1="${90 - totalHeight * 3}" x2="23" y2="${90 - totalHeight * 3}" 
                          stroke="#9b59b6" stroke-width="1.5"/>
                    <text x="10" y="${90 - totalHeight * 1.5}" fill="#9b59b6" font-size="10" 
                          font-weight="bold" text-anchor="end">
                        Total: ${totalHeight.toFixed(1)}
                    </text>
                    
                    <!-- Ground line -->
                    <line x1="10" y1="90" x2="190" y2="90" stroke="#333" stroke-width="2"/>
                    
                    <!-- Labels -->
                    <text x="100" y="105" fill="#666" font-size="9" text-anchor="middle">Side View (mm)</text>
                </svg>
            `;
            
            document.getElementById('sideView').innerHTML = svg;
        }
        
        function drawPreview(data) {
            const { pillars, holes, bounds } = data;
            
            const container = canvas.parentElement;
            const canvasWidth = container.clientWidth;
            const canvasHeight = container.clientHeight;
            
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            const innerWidth = bounds.maxX - bounds.minX;
            const innerHeight = bounds.maxY - bounds.minY;
            const wt = parseFloat(params.wallThickness.value);
            const totalWidth = innerWidth + 2 * wt;
            const totalHeight = innerHeight + 2 * wt;
            
            const scale = Math.min(canvasWidth, canvasHeight) * previewZoom / Math.max(totalWidth, totalHeight);
            
            const offsetX = canvasWidth / 2 - (bounds.minX + bounds.maxX) / 2 * scale;
            const offsetY = canvasHeight / 2 - (bounds.minY + bounds.maxY) / 2 * scale;
            
            const toScreen = (x, y) => ({
                x: x * scale + offsetX,
                y: y * scale + offsetY
            });
            
            // Draw walls
            ctx.fillStyle = 'rgba(100, 100, 100, 0.2)';
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            const wtScaled = wt * scale;
            ctx.fillRect(bounds.minX * scale + offsetX - wtScaled, bounds.minY * scale + offsetY - wtScaled, innerWidth * scale + 2*wtScaled, wtScaled);
            ctx.strokeRect(bounds.minX * scale + offsetX - wtScaled, bounds.minY * scale + offsetY - wtScaled, innerWidth * scale + 2*wtScaled, wtScaled);
            ctx.fillRect(bounds.minX * scale + offsetX - wtScaled, bounds.maxY * scale + offsetY, innerWidth * scale + 2*wtScaled, wtScaled);
            ctx.strokeRect(bounds.minX * scale + offsetX - wtScaled, bounds.maxY * scale + offsetY, innerWidth * scale + 2*wtScaled, wtScaled);
            ctx.fillRect(bounds.minX * scale + offsetX - wtScaled, bounds.minY * scale + offsetY, wtScaled, innerHeight * scale);
            ctx.strokeRect(bounds.minX * scale + offsetX - wtScaled, bounds.minY * scale + offsetY, wtScaled, innerHeight * scale);
            ctx.fillRect(bounds.maxX * scale + offsetX, bounds.minY * scale + offsetY, wtScaled, innerHeight * scale);
            ctx.strokeRect(bounds.maxX * scale + offsetX, bounds.minY * scale + offsetY, wtScaled, innerHeight * scale);
            
            // Draw floor outline
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 2;
            ctx.strokeRect(
                bounds.minX * scale + offsetX,
                bounds.minY * scale + offsetY,
                innerWidth * scale,
                innerHeight * scale
            );
            
            // Draw holes (batched)
            const holeRadiusScaled = parseFloat(params.holeRadius.value) * scale;
            ctx.fillStyle = 'rgba(255, 100, 100, 0.5)';
            ctx.beginPath();
            holes.forEach(hole => {
                const pos = toScreen(hole.x, hole.y);
                ctx.moveTo(pos.x + holeRadiusScaled, pos.y);
                ctx.arc(pos.x, pos.y, holeRadiusScaled, 0, Math.PI * 2);
            });
            ctx.fill();
            
            // Draw pillars (batched)
            const pillarRadiusScaled = parseFloat(params.pillarRadius.value) * scale;
            ctx.fillStyle = 'rgba(50, 120, 200, 0.7)';
            ctx.beginPath();
            pillars.forEach(pillar => {
                const pos = toScreen(pillar.x, pillar.y);
                ctx.moveTo(pos.x + pillarRadiusScaled, pos.y);
                ctx.arc(pos.x, pos.y, pillarRadiusScaled, 0, Math.PI * 2);
            });
            ctx.fill();
            
            // Draw measurements if enabled
            if (showMeasurements) {
                drawMeasurements(data, scale, offsetX, offsetY, bounds);
            }
            
            // Draw pillars (batched)
            const pillarRadius = parseFloat(params.pillarRadius.value) * scale;
            ctx.fillStyle = 'rgba(50, 120, 200, 0.7)';
            ctx.beginPath();
            pillars.forEach(pillar => {
                const pos = toScreen(pillar.x, pillar.y);
                ctx.moveTo(pos.x + pillarRadius, pos.y);
                ctx.arc(pos.x, pos.y, pillarRadius, 0, Math.PI * 2);
            });
            ctx.fill();
        }
        
        function updateStats(data) {
            const { pillars, holes, bounds } = data;
            const innerWidth = bounds.maxX - bounds.minX;
            const innerHeight = bounds.maxY - bounds.minY;
            const wt = parseFloat(params.wallThickness.value);
            const totalWidth = innerWidth + 2 * wt;
            const totalHeight = innerHeight + 2 * wt;
            const totalHeightZ = parseFloat(params.floorThickness.value) + parseFloat(params.pillarHeight.value);
            const density = pillars.length / (innerWidth * innerHeight);
            
            document.getElementById('statPillars').textContent = pillars.length;
            document.getElementById('statHoles').textContent = holes.length;
            document.getElementById('statDims').textContent = `${innerWidth.toFixed(2)} × ${innerHeight.toFixed(2)} mm`;
            document.getElementById('statTotal').textContent = `${totalWidth.toFixed(2)} × ${totalHeight.toFixed(2)} mm`;
            document.getElementById('statDensity').textContent = `${density.toFixed(2)} pillars/mm²`;
            document.getElementById('statHeight').textContent = `${totalHeightZ.toFixed(2)} mm`;
        }
        
        // Generate STL
        document.getElementById('generateBtn').addEventListener('click', async () => {
            const btn = document.getElementById('generateBtn');
            const status = document.getElementById('status');
            
            btn.disabled = true;
            
            const startTime = Date.now();
            const timer = setInterval(() => {
                const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                status.textContent = `Generating... ${elapsed}s`;
            }, 100);
            
            const data = {
                layout_type: params.layoutType.value,
                rows: parseInt(params.rows.value),
                cols: parseInt(params.cols.value),
                spacing: parseFloat(params.spacing.value),
                pillar_radius: parseFloat(params.pillarRadius.value),
                pillar_height: parseFloat(params.pillarHeight.value),
                hole_radius: parseFloat(params.holeRadius.value),
                floor_thickness: parseFloat(params.floorThickness.value),
                floor_padding_x: parseFloat(params.floorPaddingX.value),
                floor_padding_y: parseFloat(params.floorPaddingY.value),
                wall_thickness: parseFloat(params.wallThickness.value),
                hole_probability: parseFloat(params.holeProb.value),
                jitter: parseFloat(params.jitter.value),
                seed: parseInt(params.seed.value)
            };
            
            try {
                const response = await fetch(`${API_URL}/generate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                
                clearInterval(timer);
                
                const genTime = response.headers.get('X-Generation-Time');
                const dims = response.headers.get('X-Dimensions');
                
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `pillar_grid_${params.layoutType.value}.stl`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                
                status.textContent = `Generated in ${genTime}s (${dims})`;
                
                setTimeout(() => {
                    status.textContent = '';
                }, 5000);
                
            } catch (error) {
                clearInterval(timer);
                status.textContent = `Error: ${error.message}`;
                console.error('Generation error:', error);
            } finally {
                btn.disabled = false;
            }
        });
        
        // Initial preview
        updatePreview();
    </script>
</body>
</html>